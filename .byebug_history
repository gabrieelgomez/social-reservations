continue
square
continue
square['ranking_id'].to_i
square['ranking_id']
@reservation.reservationable
@reservation
a = square['doubles'].to_i || 0
a = square['single'].to_i || 0
a = square['single'] || 0
square['single']
square
a = square[:single]
a = square[:single] || 0
a = square[:doubles] || 0
a = square[:doubles]
square
exit
square
exit
room.keys.include?(:total_price_table)
room.keys
room
continue
@table.last[:total_price_table]
@table.last
@table.last.keys.include?(:total_price_table)
@table.last.keys.inclued?(:total_price_table)
@table.last.keys.inclue?(:total_price_table)
@table.last.keys
@table.last
@table
@table.push(total_price_table: @table.map{|room| room[:total_room]}.sum)
@table
@table.map{|room| room[:total_room]}
@table.map{|room| room[:total_room]}.sum
@table.map{|room| room[:total_room]}.inject(:+)
@table.map{|room| room[:total_room]}
@table.map{|room| room[:total_room]}.prom
@table.map{|room| room[:total_room]}
@table.flatten.keys
@table.flatten
@table
@table.keys
@table.map(&:total_room)
@table.map(:total_room)
@table.map(&:total_room)
@table
exit
@table
continue
room[:quantity]
room[:price]
table
room[:type]
room[:Type]
room
exit
continue
table
room
continue
@table
continue
@table
@table.third
continue
@table.third
@table.second
@table.first
@table
continue
@table
continue
@table
exit
room.try("price_#{currency}")
@table
exit
continue
square.each{|k,v| circuitable.circuitable_rooms.select{|x| x.type_room == k}  }
square.each{|k,v| circuitable.circuitable_rooms.select{|x| puts x.type_room == k}  }
square.each{|k,v| circuitable.circuitable_rooms.select{|x| x.type_room == k}  }
price = circuitable.circuitable_rooms.select{|x| x.type_room == room[0]}.first.try("price_#{@currency}")
square.each{|k,v| k}
square.each{|k,v| puts v}
square.each{|k,v|puts k}
square
price = circuitable.circuitable_rooms.select{|x| x.type_room == room[0]}.first.try("price_#{@currency}")
price = circuitable.circuitable_rooms.select{|x| x.type_room == room[0]}.first.type_room
price = circuitable.circuitable_rooms.select{|x| x.type_room == room[0]}
price = circuitable.circuitable_rooms.select{|x| x.type_room == room[0]}.first.try("price_#{@currency}")
room
@algo = []
square
continue
session[:square_circuit].first.select{|_, value| !value.empty?}['ranking_id']
session[:square_circuit].first.select{|_, value| !value.empty?}
session[:square_circuit].first
session[:square_circuit].first.select{|_, value| value.empty?}
session[:square_circuit].first
session[:square_circuit].first.
session[:square_circuit].first.compact
session[:square_circuit].first.values.reject(&:blank?)
session[:square_circuit].first.values.reject(&:blank?).min
session[:square_circuit].first.values.to_i.reject(&:zero?).min
session[:square_circuit].first.values.reject(&:zero?).min
session[:square_circuit].first.values
session[:square_circuit].first
session[:square_circuit].keys
session[:square_circuit].value
session[:square_circuit].vals
session[:square_circuit].values
session[:square_circuit].values_at
session[:square_circuit].values_at.reject(&:zero?)
session[:square_circuit].values.reject(&:zero?)
session[:square_circuit].reject(&:zero?).min
session[:square_circuit]
exit
total = self.circuitable_rooms.collect{|room| room.price_cop * square[room.type_room].to_i }.reject(&:zero?)
total = self.circuitable_rooms.collect{|room| room.price_cop * square[room.type_room].to_i }.reject(&:zero?).min
total = self.circuitable_rooms.collect{|room| room.price_cop * square[room.type_room].to_i }
square
self.circuitable_rooms.first.type_room
self.circuitable_rooms.first
square
continue
square
continue
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.first
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.first.price_cop
circuitable.circuitable_rooms.find_by(type_room: 'single')
circuitable.circuitable_rooms.find_by(type_room: 'single'}
circuitable.circuitable_rooms.find_by(type_room: 'single'}.price_cop
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.price_cop
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.first.price_cop
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.price_cop
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}.count
circuitable.circuitable_rooms.select{|x| x.type_room == 'single'}
circuitable.circuitable_rooms
circuitable
circuitable.ranking.title
circuitable.ranking.title[]
circuitable.ranking
circuitable
circuitable = circuit.circuitables.find_by(ranking_id: session[:square_circuit].first['ranking_id'])
circuitable = circuit.circuitables.find_by(ranking_id)(session[:square_circuit].first['ranking_id'])
circuitable = circuit.circuitables.find(session[:square_circuit].first['ranking_id'])
circuit.circuitables
circuit.circuitable_rooms.select{|x| x.type_room == 'single'}.last
circuit.circuitable_rooms.select{|x| x.type_room == 'single'}.Ã±ast
circuit.circuitable_rooms.select{|x| x.type_room == 'single'}.count
circuit.circuitable_rooms.select{|x| x.type_room == 'single'}
circuit.circuitable_rooms.first
circuit.circuitable_rooms.first.type_room
circuit.circuitable_rooms.first
circuit.circuitable_rooms.first.room
circuit.circuitable_rooms.first.ranking
circuit.circuitable_rooms.first.ranking_id
circuit.circuitable_rooms.first.ranking
circuit.circuitable_rooms.first
circuit.circuitable_rooms
type_lodgment.circuitable_rooms
type_lodgment.rooms
type_lodgment
continue
type_lodgment = circuit.rankings.find(session[:square_circuit].first['ranking_id'])
circuit = KepplerTravel::Circuit.find(session[:reservationable]['id']) 
type_lodgment = circuit.rankings.find(session[:square_circuit].first['ranking_id'])
type_lodgment.title
type_lodgment = circuit.rankings.find(session[:square_circuit].first['ranking_id'])
circuit.rankings.find(session[:square_circuit].first['ranking_id'])
circuit = KepplerTravel::Circuit.find(session[:reservationable]['id']) 
circuit.rankings.find(session[:square_circuit].first['ranking_id'])
session[:square_circuit]['single']
session[:square_circuit][:ranking_id]
session[:square_circuit]
session[:square_circuit]['ranking_id']
circuit.rankings.find(session[:square_circuit]['ranking_id'].to_i)
circuit.rankings.find(1)
circuit.rankings.find
circuit.rankings
circuit.rankings.find(session[:square_circuit]['ranking_id'])
circuit
circuit = KepplerTravel::Circuit.find(session[:reservationable]['id']) 
session[:reservationable]
session[:reservation]['quantity_kids']
session[:reservation][:quantity_kids]
session[:reservation]
session[:square_circuit]
continue
@circuit.circuitables.count
@circuit.circuitables
continue
session[:reservation]
session[:reservation].nil?
continue
session[:reservation]
session[:user]
session[:invoice]
session[:travellers]
session[:reservationable]
session[:square_circuit]
continue
session[:square_circuit]
continue
session[:square_circuit][0].first
session[:square_circuit][0]
session[:square_circuit][0][1]
session[:square_circuit][0][0]
session[:square_circuit][0].values
session[:square_circuit][0].keys
session[:square_circuit][0]['triples']
session[:square_circuit][0]
session[:square_circuit]
continue
@lodgments
continue
params
params[:square_circuit]
params
asdasd
ss
continue
room.first.room
room.first.room.type
room.first.room.room_type
room.room_id
room.room
room.room_type
room.room
room.count
room
index
exit
index
i
exit
continue
single = circuitable.circuitable_rooms[0]
circuitable.circuitable_rooms[6]
circuitable.circuitable_rooms[7]
circuitable.circuitable_rooms[0]
circuitable.circuitable_rooms
continue
a = 0 if ids
a = 0 unless ids
ids
continue
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten.reject(&:zero?).min
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten.reject(&:zero?)
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten.reject(&:zero?).min
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten.reject(&:zero?)
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten.reject
@results.circuitables.collect{|cc|  cc.circuitable_rooms.map(&:price_cop)}.flatten
